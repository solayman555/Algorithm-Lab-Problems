int binarySearch(int arr[], int size, int target) {
    int left = 0;
    int right = size - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
                if (arr[mid] == target)
            return mid;
        if (arr[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
        return -1; //index return
}
////////sorting
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}
int main() {
 int n = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, n, sizeof(int), compare);
    return 0;
}
//////////max min
int max=arr[0],min=arr[0];
for(int i=1;i<n;i++)
{if(arr[i] > max) max=arr[i];
if(arr[i]< min)min=arr[]i];}
////////sum 21
qsort
 while (left < right) {
            int sum = arr[left] + arr[right];
            if (sum == m) {
                a = arr[left];
                b = arr[right];
                left++;
                right--;
            } else if (sum < m) {
                left++;
            } else {
                right--;
            }
        }
////////EOF
#include <math.h>
#define EPSILON 1e-7
double bisection(int p, int q, int r, int s, int t, int u) {
    double lo = 0.0, hi = 1.0, mid;
    while ((hi - lo) > EPSILON) {
        mid = (lo + hi) / 2.0;
        if (f(lo, p, q, r, s, t, u) * f(mid, p, q, r, s, t, u) <= 0)
            hi = mid;
        else
            lo = mid;}
    return (lo + hi) / 2.0;
}
int main() {
    int p, q, r, s, t, u;
    while (scanf("%d %d %d %d %d %d", &p, &q, &r, &s, &t, &u) != EOF) {
        double f_lo = f(0.0, p, q, r, s, t, u);
        double f_hi = f(1.0, p, q, r, s, t, u);
        if (f_lo * f_hi > 0) {
            printf("No solution\n");
        } else {
            double root = bisection(p, q, r, s, t, u);
            printf("%.4f\n", root);
        }
    }
///////////boundrey
int upper_bound(int arr[], int n, int target) {
    int left = 0, right = n;
    while (left < right) {
        int mid = (left + right) / 2;
        if (arr[mid] <= target) ///for lower no =
            left = mid + 1;
        else
            right = mid;
    }
    return left;
}
