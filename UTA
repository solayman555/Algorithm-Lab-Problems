int binarySearch(int arr[], int size, int target) {
    int left = 0;
    int right = size - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
                if (arr[mid] == target)
            return mid;
        if (arr[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
        return -1; //index return
}
////////sorting
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}
int main() {
 int n = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, n, sizeof(int), compare);
    return 0;
}
//////////max min
int max=arr[0],min=arr[0];
for(int i=1;i<n;i++)
{if(arr[i] > max) max=arr[i];
if(arr[i]< min)min=arr[]i];}
////////sum 21
qsort
 while (left < right) {
            int sum = arr[left] + arr[right];
            if (sum == m) {
                a = arr[left];
                b = arr[right];
                left++;
                right--;
            } else if (sum < m) {
                left++;
            } else {
                right--;
            }
        }
////////EOF
#include <math.h>
#define EPSILON 1e-7
double bisection(int p, int q, int r, int s, int t, int u) {
    double lo = 0.0, hi = 1.0, mid;
    while ((hi - lo) > EPSILON) {
        mid = (lo + hi) / 2.0;
        if (f(lo, p, q, r, s, t, u) * f(mid, p, q, r, s, t, u) <= 0)
            hi = mid;
        else
            lo = mid;}
    return (lo + hi) / 2.0;
}
int main() {
    int p, q, r, s, t, u;
    while (scanf("%d %d %d %d %d %d", &p, &q, &r, &s, &t, &u) != EOF) {
        double f_lo = f(0.0, p, q, r, s, t, u);
        double f_hi = f(1.0, p, q, r, s, t, u);
        if (f_lo * f_hi > 0) {
            printf("No solution\n");
        } else {
            double root = bisection(p, q, r, s, t, u);
            printf("%.4f\n", root);
        }
    }
///////////boundrey
int upper_bound(int arr[], int n, int target) {
    int left = 0, right = n;
    while (left < right) {
        int mid = (left + right) / 2;
        if (arr[mid] <= target) ///for lower no =
            left = mid + 1;
        else
            right = mid;
    }
    return left;
}
//////////0/1
int max(int a, int b) {
    return (a > b) ? a : b;
}
int main() {
    int N, W;
    scanf("%d %d", &N, &W);

    int y[201], s[201];
    for (int i = 1; i <= N; i++) {
        scanf("%d %d", &y[i], &s[i]);
    }
    int dp[100001] = {0};

    for (int i = 1; i <= N; i++) {
        for (int j = W; j >= s[i]; j--) {
            dp[j] = max(dp[j], dp[j - s[i]] + y[i]);
        }
    }
    printf("%d\n", dp[W]);
    return 0;
}
///////////SCC
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 100005
typedef struct Node {
    int v;
    struct Node* next;
} Node;
Node* graph[MAX];
Node* rev_graph[MAX];
int visited[MAX];
int stack[MAX];
int top = -1;

void push(int x) {
    stack[++top] = x;
}
int pop() {
    return stack[top--];
}
Node* newNode(int v) {
    Node* temp = (Node*)malloc(sizeof(Node));
    temp->v = v;
    temp->next = NULL;
    return temp;
}
void addEdge(Node* graph[], int u, int v) {
    Node* temp = newNode(v);
    temp->next = graph[u];
    graph[u] = temp;
}
void dfs1(int u) {
    visited[u] = 1;
    Node* cur = graph[u];
    while (cur) {
        if (!visited[cur->v]) dfs1(cur->v);
        cur = cur->next;
    }
    push(u);
}
void dfs2(int u) {
    visited[u] = 1;
    Node* cur = rev_graph[u];
    while (cur) {
        if (!visited[cur->v]) dfs2(cur->v);
        cur = cur->next;
    }
}
int main() {
    int N, M;
    scanf("%d %d", &N, &M);
    for (int i = 1; i <= N; i++) {
        graph[i] = NULL;
        rev_graph[i] = NULL;
    }
    for (int i = 0; i < M; i++) {
        int v, u;
        scanf("%d %d", &v, &u); 
        addEdge(graph, u, v);
        addEdge(rev_graph, v, u);
    }
    memset(visited, 0, sizeof(visited));
    for (int i = 1; i <= N; i++) {
        if (!visited[i]) dfs1(i);
    }
    memset(visited, 0, sizeof(visited));
    int scc_count = 0;
    while (top != -1) {
        int u = pop();
        if (!visited[u]) {
            dfs2(u);
            scc_count++;
        }
    }
    printf("%d\n", scc_count);
    return 0;
}
////////min coin
#include <stdio.h>
#include <limits.h>
#define MAX_K 1000005
#define INF 1000000000
int dp[MAX_K];
int min(int a, int b) {
    return a < b ? a : b;}
int main() {
    int n, m, k;
    scanf("%d %d %d", &n, &m, &k);
    int A[1005], B[25];
    for (int i = 0; i < n; i++)
        scanf("%d", &A[i]);
    for (int i = 0; i < m; i++)
        scanf("%d", &B[i]);
    for (int i = 0; i <= k; i++)
        dp[i] = INF;

    dp[0] = 0;
    for (int i = 0; i < m; i++) {
        int coin = B[i];
        for (int j = coin; j <= k; j++) {
            dp[j] = min(dp[j], dp[j - coin] + 1);
        }}
    int C = dp[k];
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (A[i] > C)
            count++;
    }
    printf("%d\n", count);
    return 0;}
///////possible change
#include <stdio.h>#include <string.h>#define MAX_K 100005#define MOD 1000000007 
long long dp[MAX_K];
int main(){
    int m, k;
    scanf("%d %d", &m, &k);
    int coins[25];
    for (int i = 0; i < m; i++)
        scanf("%d", &coins[i]);
    dp[0] = 1;
    for (int i = 0; i < m; i++) {
        int coin = coins[i];
        for (int j = coin; j <= k; j++) {
            dp[j] = (dp[j] + dp[j - coin]) % MOD;
        }}
    printf("Number of ways to make %d: %lld\n", k, dp[k]);
    return 0;}
//////////topsort
#include <stdio.h>#include <stdlib.h>#define MAXN 100005
int adj[MAXN][100];int deg[MAXN];int q[MAXN];int pos[MAXN];int idx[MAXN];int front, back;
int cmp(const void* a, const void* b) {
    return ((int*)a)[0] - ((int*)b)[0];
}
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        int n, m;
        scanf("%d %d", &n, &m);
        int adjCount[MAXN] = {0};
        for (int i = 0; i <= n; i++) {
            deg[i] = 0;
        }for (int i = 0; i < m; i++) {
            int u, v;
            scanf("%d %d", &u, &v);
            adj[u][adjCount[u]++] = v;
            deg[v]++;
        }front = back = 0;
        for (int i = 1; i <= n; i++) {
            if (deg[i] == 0) {
                q[back++] = i;
            }      }
        int topSort[MAXN];
        int index = 0;

        while (front < back) {
            int u = q[front++];
            topSort[index++] = u;
            for (int i = 0; i < adjCount[u]; i++) {
                int v = adj[u][i];
                deg[v]--;
                if (deg[v] == 0) {
                    q[back++] = v;
                }}}
        if (index < n) {
            printf("NO\n"); // cycle exists
        } else {
            int valid = 1;
            for (int i = 0; i < n; i++) {
                pos[topSort[i]] = i;
            }

            for (int i = 1; i < n; i++) {
                if (pos[i] > pos[i + 1]) {
                    valid = 0;
                    break;
                }
            }
if (valid) {
                printf("YES\n");
                for (int i = 0; i < n; i++) {
                    printf("%d ", topSort[i]);
                }
                printf("\n");
            } else {
                printf("NO\n");
            }}}
    return 0;
}

