int binarySearch(int arr[], int size, int target) {
    int left = 0;
    int right = size - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
                if (arr[mid] == target)
            return mid;
        if (arr[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
        return -1; //index return
}
////////sorting
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}
int main() {
 int n = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, n, sizeof(int), compare);
    return 0;
}
//////////max min
int max=arr[0],min=arr[0];
for(int i=1;i<n;i++)
{if(arr[i] > max) max=arr[i];
if(arr[i]< min)min=arr[]i];}
////////sum 21
qsort
 while (left < right) {
            int sum = arr[left] + arr[right];
            if (sum == m) {
                a = arr[left];
                b = arr[right];
                left++;
                right--;
            } else if (sum < m) {
                left++;
            } else {
                right--;
            }
        }
////////EOF
#include <math.h>
#define EPSILON 1e-7
double bisection(int p, int q, int r, int s, int t, int u) {
    double lo = 0.0, hi = 1.0, mid;
    while ((hi - lo) > EPSILON) {
        mid = (lo + hi) / 2.0;
        if (f(lo, p, q, r, s, t, u) * f(mid, p, q, r, s, t, u) <= 0)
            hi = mid;
        else
            lo = mid;}
    return (lo + hi) / 2.0;
}
int main() {
    int p, q, r, s, t, u;
    while (scanf("%d %d %d %d %d %d", &p, &q, &r, &s, &t, &u) != EOF) {
        double f_lo = f(0.0, p, q, r, s, t, u);
        double f_hi = f(1.0, p, q, r, s, t, u);
        if (f_lo * f_hi > 0) {
            printf("No solution\n");
        } else {
            double root = bisection(p, q, r, s, t, u);
            printf("%.4f\n", root);
        }
    }
///////////boundrey
int upper_bound(int arr[], int n, int target) {
    int left = 0, right = n;
    while (left < right) {
        int mid = (left + right) / 2;
        if (arr[mid] <= target) ///for lower no =
            left = mid + 1;
        else
            right = mid;
    }
    return left;
}
//////////0/1
int max(int a, int b) {
    return (a > b) ? a : b;
}
int main() {
    int N, W;
    scanf("%d %d", &N, &W);

    int y[201], s[201];
    for (int i = 1; i <= N; i++) {
        scanf("%d %d", &y[i], &s[i]);
    }
    int dp[100001] = {0};

    for (int i = 1; i <= N; i++) {
        for (int j = W; j >= s[i]; j--) {
            dp[j] = max(dp[j], dp[j - s[i]] + y[i]);
        }
    }
    printf("%d\n", dp[W]);
    return 0;
}
///////////SCC
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 100005
typedef struct Node {
    int v;
    struct Node* next;
} Node;
Node* graph[MAX];
Node* rev_graph[MAX];
int visited[MAX];
int stack[MAX];
int top = -1;

void push(int x) {
    stack[++top] = x;
}
int pop() {
    return stack[top--];
}
Node* newNode(int v) {
    Node* temp = (Node*)malloc(sizeof(Node));
    temp->v = v;
    temp->next = NULL;
    return temp;
}
void addEdge(Node* graph[], int u, int v) {
    Node* temp = newNode(v);
    temp->next = graph[u];
    graph[u] = temp;
}
void dfs1(int u) {
    visited[u] = 1;
    Node* cur = graph[u];
    while (cur) {
        if (!visited[cur->v]) dfs1(cur->v);
        cur = cur->next;
    }
    push(u);
}
void dfs2(int u) {
    visited[u] = 1;
    Node* cur = rev_graph[u];
    while (cur) {
        if (!visited[cur->v]) dfs2(cur->v);
        cur = cur->next;
    }
}
int main() {
    int N, M;
    scanf("%d %d", &N, &M);
    for (int i = 1; i <= N; i++) {
        graph[i] = NULL;
        rev_graph[i] = NULL;
    }
    for (int i = 0; i < M; i++) {
        int v, u;
        scanf("%d %d", &v, &u); 
        addEdge(graph, u, v);
        addEdge(rev_graph, v, u);
    }
    memset(visited, 0, sizeof(visited));
    for (int i = 1; i <= N; i++) {
        if (!visited[i]) dfs1(i);
    }
    memset(visited, 0, sizeof(visited));
    int scc_count = 0;
    while (top != -1) {
        int u = pop();
        if (!visited[u]) {
            dfs2(u);
            scc_count++;
        }
    }
    printf("%d\n", scc_count);
    return 0;
}
////////
